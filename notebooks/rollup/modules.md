# Modules

## Bundle Creation

* firstly, the bundle is created
  * contains only the _necessary_ code ❓

* the `Graph` is created
  * holds the `acorn parser`
  * holds the `PluginDriver` - entity
  * holds the `Global Scope`
  * what's its main role ❓
  * by default it includes these acorn plugins
    ```ts
    acornPluginsToInject.push(
			injectImportMeta, // `import.meta`
			injectExportNsFrom, // `export * from`
			injectClassFields, // `class Foo { prop = 'prop'; #privateProp = 'privateProp' }`
			injectStaticClassFeatures // class Foo { static prop = '123' }
		);
    ```
  * the `ModuleLoader` is created
    * responsible for properly loading a module(e.g fetching its dependencies)
    * calling certain hooks - `load`, `resolveId`
    * `getHasModuleSideEffects` ? 
  
* **build phase**
  * 

## Loading modules

* after the file has been read
  * the first `AST` is generated by the `acorn parser`
  * this `AST` is then analyzed; rollup creates a new `AST` based on the one generated by `acorn`;
   
    this is useful as each node holds important logic(e.g: `ImportDeclaration`);
    each node of rollup's `AST` corresponds to a node of `acorn`'s `AST`

    each rollup node holds a reference to the current module that's being fetched:
    ```ts
    this.astContext = { /* ... */ }
    ```
  * the (dynamic/not dynamic)dependencies are fetched: the modules(`Module.sources` -> populated in `addImport`) that the current module depends on will be resolved
  * during this phase, it also adds variables to their scope -> a tree of scopes

* resolving dependencies: `resolvedIds`
* linking dependencies & determining circular dependencies
* `ast.bind`



## Internal Modules

## External Modules

* you can provide an array of `RegExp`/ids(full paths maybe) for the `InputOptions.external` option
* it is a module that does not have other dependencies 

## Other relevant entities

### Graph

### ModuleLoader

* held by: `Graph`
* holds the **global scope**

### Module

* holds a scope: `ModuleScope`(child scope); it has a local `this`
  * a new variable is added when a `module scope` is created

* `importDescriptions[k] = v`; 
  `k` - the `local` name of the import
    ```ts
    import foo from './foo'; // specifier.local.name = `k` = `foo`
    import { foo as test } from './foo'; // specifier.local.name = `k` = `test`; specifier.local.imported = 'foo'
    ```
  `v` - specifier `{ module, name: 'default' '*', '{ thisName }', source: string, start: number }`
  
  filled by `addImport`; in `addModulesToImportDescriptions`, `resolvedIds` are _connected_ with `importDescriptions`

  ❓ `addModulesToImportDescriptions`- where the module from `specifier` is `filled in`(`module: null as any, // filled in later`)

* `Module.traceVariable()`
  `if (name in this.importDescriptions) {}`: during _binding phase_, when the `callee` of the `CallExpression` is an `identifier`(e.g: `foo()`); this is going to set the variable

  a variable can either be in this **module's scope**, on it is **imported from another module**(calling `otherModule.getVariableForExportName`)

* `Module.getVariableForExportName()`
  * invoked when a dependant module calls for variables that are not declared in the its(dependant's) scope;
  * checks the local variables; then `export { var } from '...'`; then the variables exported by this module(e.g: `export const foo = 123;`, `export default () => {}`); if still not found, it will try to find it by recursively looking through the `export *` modules ⬇️

  `getVariableForExportNameRecursive()`
    * search a variable name through `export *` modules(which are kept in `this.exportAllModules`)


### Variable

* what is a `declarator`

### AST node

* has a ref to its `parent`, the module's scope(`child scope`)

## To Try

* multiple inputs
* `-i` option; 
* `InputOptions.{perf, cache.{modules, plugins}, experimentalCacheExpiry, shimMissingExports, context, moduleContext, preserveSymlinks}`
* `InputOptions.preserveModules` -  Preserve module's structure - not hoisting transitive dependencies
* `InputOptions.strictDeprecations` - make errors out of warnings
* `InputOptions.{acornInjectPlugins, acorn}` - custom options for `acorn`
* `markPureCallExpressions`
* dynamic dependencies
* manual chunks
* `dynamicallyImportedBy`
* `EntryModule`(provided via **input option**) vs a `Module`(a dependency)
* how are circular dependencies avoided(`barrel` file ❓)
* `dynamicImports`
* `getPathIfNotComputed`
  ```ts
  if (object instanceof Identifier) {} // **console**.log();
  if (object instanceof MemberExpression) {} // a.b().c()
  ``` 
* what kind of expression is `**foo()**.log()` ?
* `MemberExpression` -> `bind()` -> `if (baseVariable && baseVariable.isNamespace)`
  -> `getPropertyKey()` `this.propertyKey === null` ? `foo['test']()`
* `CallExpression` -> `bind()`-> `if (this.callee instanceof Identifier)` foo()
* `export *` / `import *`
